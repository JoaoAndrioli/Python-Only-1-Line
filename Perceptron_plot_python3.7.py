# BASED ON https://github.com/Honghe/perceptron
# Totally not optimized, I'll make a python 3.8 version soon
from matplotlib.pylab import *
import numpy as np
import random

generateData = lambda n: [[((np.random.rand(n)*2-1)/2-0.5)[i] , ((np.random.rand(n)*2-1)/2+0.5)[i], 1] if i < n else [((np.random.rand(n)*2-1)/2+0.5)[i-n], ((np.random.rand(n)*2-1)/2-0.1)[i-n], -1] for i in range(n*2)]
plot_perceptron = lambda data,testset,gE=0.0,w=[[random.random()*2-1 for _ in range(2)]]:[[print('not hit.') if [1 if sum([i * j for i, j in zip([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1], predict)]) >= 0 else -1][0] != predict[2] else plot(predict[0], predict[1], 'ob') if [1 if sum([i * j for i, j in zip([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1], predict)]) >= 0 else -1][0] == 1 else plot(predict[0], predict[1], 'or') for predict in testset], plot([([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1] / norm([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1]))[1], -([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1] / norm([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1]))[1]], [-([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1] / norm([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1]))[0], ([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1] / norm([next(0 for _ in range(100) if gE+sum([x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0] for x in data if (x[2] != [1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) and w.append([i + 0.1 * (x[2]-[1 if sum([i * j for i, j in zip(w[-1], x)]) >= 0 else -1][0]) * j for i, j in zip(w[-1], x)]) == None])==0.0),w[-1]][1]))[0]], '--k'),show()]

trainset,testset= generateData(40),generateData(15) 
plot_perceptron(trainset,testset);
